Bytewise: The Hyper-Contextual AI Learning PlatformBytewise is not just another study tool. It's a full-stack, AI-powered academic ecosystem designed to be a proactive, intelligent companion for university students.Built on the vision of creating a hyper-contextualized academic operating system, Bytewise understands who you are: your university, your program, your semester, and even your scheme. It uses this context to provide truly personalized assistance, moving beyond the reactive nature of traditional study tools.This project is built to be open-source and self-hostable, allowing any educational institution, from a small student club (like an IEEE or IEDC chapter) to a full university, to deploy and integrate it into their local systems. By connecting to real institutional data like attendance and exam results, Bytewise is designed to become a central, indispensable platform for modern education.üöÄ Key FeaturesBytewise is a fully integrated platform. Here are the core features currently implemented:üéì Personalized User Profiles: Full authentication (signup/login) that captures a user's University, Program, Semester, and Scheme (e.g., for KTU).ü§ñ Contextual AI Chatbot: A dashboard-integrated chatbot (powered by the Gemini API) that knows the user's academic profile and can answer questions in the context of their specific courses and semester.üîÑ Automated Course Retrieval: When a user logs in, Bytewise automatically finds their course list for the current semester. It does this using a resilient, multi-stage "Engineered Search" engine.üóìÔ∏è Dynamic Academic Schedule: The dashboard displays key upcoming dates (like exams) from the user's academic calendar.Smart PDF Parsing: Users can upload their university's academic calendar (even text-based or scanned PDFs).Hybrid PDF Parser: The system uses a two-pass "NLM" to extract data:It first attempts a fast, row-based text extraction (tailored for summary tables).If that fails, it falls back to a full OCR (Tesseract.js) parse to read text from image-based PDFs, intelligently skipping cover pages.üß† AI Topic Summarizer: A dedicated page where users can paste study materials and receive a summary generated by the Gemini API, tailored to their academic level.‚úçÔ∏è AI Practice Quiz Generator: Users can provide a topic and study materials to generate a custom, multiple-choice quiz on the fly, complete with scoring.üìä Contextual Course Analysis: A "deep-dive" page where a user can select one of their courses. The system then performs an engineered web search to find and display relevant YouTube lectures and module-wise notes, all based on the user's specific university profile.üìú Paper Analyzer & PYQ Manager: A tool for analyzing Previous Year Question (PYQ) papers.A user selects one of their courses from a dropdown.They upload a PYQ PDF.The backend (using pdfreader) analyzes the text to find and count the frequency of key topics.These results are then saved to the user's profile in the database.‚ö° Express Mode (Exam Season):The app automatically detects if the user is in their "exam season" (e.g., November for odd semesters).If they are, the dashboard replaces the "Upcoming Tasks" card with a dynamic "Express Study Options" card, providing direct links to a comprehensive study page for each of their courses.This "Express Mode" page displays the real, user-uploaded PYQ analysis, notes, and summaries, creating an all-in-one revision hub.üîÉ Automatic Semester Updates: A node-cron job runs on the server to automatically check and increment a user's semester every 6 months, ensuring their course list and context are always up-to-date.üõ†Ô∏è Tech StackThis project is built with a modern, decoupled, full-stack architecture.ComponentTechnologyDescriptionFrontendReact (with Vite)A fast, modern React frontend built in TypeScript.Tailwind CSSFor utility-first styling and the dark-mode theme.shadcn/uiFor the beautiful, accessible component library.React RouterFor all client-side navigation.BackendNode.jsThe core JavaScript runtime.Express.jsFor building the RESTful API endpoints.MySQLThe relational database for all user data, courses, and cached analysis.AuthenticationJWT (JSON Web Tokens)For secure, stateless user sessions.AI FeaturesGemini APIPowers the chatbot, summarizer, and course analysis.Scraping EnginePuppeteerA headless browser used to perform intelligent web searches."Local NLM"pdfreader / compromise.jsUsed for robust PDF text extraction and heuristic-based text analysis.tesseract.js (OCR)Used as a fallback to read text from image-based PDF calendars.‚öôÔ∏è How Our "Engineered Search" WorksA core strength of Bytewise is its ability to find content without relying on a single website or a paid, closed-source API.Problem: How do you find a student's courses or academic calendar, which could be on any university website with any HTML structure?Solution: The Hybrid ScraperEngineered Query: The system builds a hyper-specific search query based on the user's profile (e.g., "KTU CSE s5 academic schedule").Scrape Search Results: Puppeteer performs a full web search on an open-source engine (like DuckDuckGo) and scrapes the top 4 URLs. It prioritizes official .edu links.Iterative Analysis (Pass 1): It visits the first URL and scrapes all its raw text.Local NLP Extraction (Pass 1): This text is passed to our "Lightweight NLM" (e.g., local-nlp.service.js), which uses a set of smart rules, keywords, and regular expressions to find and extract the relevant data (e.g., course names).Iterative Analysis (Pass 2): If the first pass on a page fails to find text, the system then attempts a "deep" parse, looking for specific download links (like .pdf or drive.google.com) and analyzing the text around them.Success or Next: If courses are found, the process stops and saves the data. If not, it moves to the next URL in the search results and tries again.This two-pass, multi-url approach makes Bytewise incredibly resilient and adaptable to the real-world web.üèÅ Getting StartedTo get a local copy up and running, follow these simple steps.PrerequisitesNode.js (v18 or later)MySQL (or a client like XAMPP/WAMP)A Google AI Studio API key (for Gemini features)1. Backend Setup# 1. Clone the repository
git clone [https://github.com/your-username/bytewise.git](https://github.com/your-username/bytewise.git)
cd bytewise/server

# 2. Install dependencies
npm install

# 3. Create your environment file
# (Create a file named .env in the /server directory)
#
# Add the following, replacing with your credentials:
#
# PORT=3001
# DB_HOST=localhost
# DB_USER=root
# DB_PASSWORD=your_mysql_password
# DB_NAME=bytewise_db
#
# JWT_SECRET=a-very-strong-and-secret-key-for-bytewise
# GEMINI_API_KEY=YOUR_GOOGLE_AI_STUDIO_KEY_HERE

# 4. Set up the database
# Log in to your MySQL shell
mysql -u root -p

# Run the following SQL commands to create the database and all tables:
CREATE DATABASE IF NOT EXISTS bytewise_db;
USE bytewise_db;

CREATE TABLE IF NOT EXISTS users (
    id INT PRIMARY KEY AUTO_INCREMENT,
    email VARCHAR(255) NOT NULL UNIQUE,
    password VARCHAR(255) NOT NULL,
    university VARCHAR(255) NOT NULL,
    program VARCHAR(255) NOT NULL,
    semester INT NOT NULL,
    scheme INT NULL,
    last_semester_update DATE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE IF NOT EXISTS courses (
    id INT PRIMARY KEY AUTO_INCREMENT,
    university VARCHAR(255) NOT NULL,
    scheme INT NULL,
    program VARCHAR(255) NOT NULL,
    semester INT NOT NULL,
    course_code VARCHAR(50) NOT NULL,
    course_name VARCHAR(255) NOT NULL,
    UNIQUE KEY unique_course (university, scheme, program, semester, course_name)
);

CREATE TABLE IF NOT EXISTS pyq_analysis_topics (
    id INT PRIMARY KEY AUTO_INCREMENT,
    user_id INT NOT NULL,
    course_name VARCHAR(255) NOT NULL,
    topic_name VARCHAR(255) NOT NULL,
    frequency INT NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
    UNIQUE KEY unique_pyq_topic (user_id, course_name, topic_name)
);

CREATE TABLE IF NOT EXISTS schedule_cache (
    id INT PRIMARY KEY AUTO_INCREMENT,
    user_id INT NOT NULL,
    event_name VARCHAR(255) NOT NULL,
    event_date DATE NOT NULL,
    fetched_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
    UNIQUE KEY unique_event_for_user (user_id, event_name, event_date)
);

# 5. Run the backend server
npm run dev
# Your backend is now running on http://localhost:3001
2. Frontend Setup# 1. Open a new terminal and navigate to the project's root folder
cd bytewise 

# 2. Install dependencies
npm install

# 3. Add shadcn/ui components (if they are missing)
# This step is often not needed if you've cloned the repo with the files.
# npx shadcn@latest add toast use-toast button card input label ...etc.

# 4. Run the frontend server
npm run dev
# Your frontend is now running on http://localhost:5173
You can now open http://localhost:5173 in your browser and use the application.
