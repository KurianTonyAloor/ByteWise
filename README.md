# **Bytewise: The Hyper-Contextual AI Learning Platform**

**Bytewise** is not just another study tool. It's a full-stack, AI-powered academic ecosystem designed to be a proactive, intelligent companion for university students.

Built on the vision of creating a **hyper-contextualized academic operating system**, Bytewise understands who you are: your university, your program, your semester, and even your scheme. It uses this context to provide truly personalized assistance, moving beyond the reactive nature of traditional study tools.

This project is built to be **open-source and self-hostable**, allowing any educational institution, from a small student club (like an IEEE or IEDC chapter) to a full university, to deploy and integrate it into their local systems. By connecting to real institutional data like attendance and exam results, Bytewise is designed to become a central, indispensable platform for modern education.

## **üöÄ Key Features**

Bytewise is a fully integrated platform. Here are the core features currently implemented:

* **üéì Personalized User Profiles:** Full authentication (signup/login) that captures a user's **University, Program, Semester,** and **Scheme** (e.g., for KTU).  
* **ü§ñ Contextual AI Chatbot:** A dashboard-integrated chatbot (powered by the Gemini API) that knows the user's academic profile and can answer questions in the context of their specific courses and semester.  
* **üîÑ Automated Course Retrieval:** When a user logs in, Bytewise automatically finds their course list for the current semester. It does this using a resilient, multi-stage "Engineered Search" engine.  
* **üóìÔ∏è Dynamic Academic Schedule:** The dashboard displays key upcoming dates (like exams) from the user's academic calendar.  
  * **Smart PDF Parsing:** Users can upload their university's academic calendar (even text-based or scanned PDFs).  
  * **Hybrid PDF Parser:** The system uses a two-pass "NLM" to extract data:  
    1. It first attempts a fast, row-based text extraction (tailored for summary tables).  
    2. If that fails, it falls back to a full **OCR (Tesseract.js)** parse to read text from image-based PDFs, intelligently skipping cover pages.  
* **üß† AI Topic Summarizer:** A dedicated page where users can paste study materials and receive a summary generated by the Gemini API, tailored to their academic level.  
* **‚úçÔ∏è AI Practice Quiz Generator:** Users can provide a topic and study materials to generate a custom, multiple-choice quiz on the fly, complete with scoring.  
* **üìä Contextual Course Analysis:** A "deep-dive" page where a user can select one of their courses. The system then performs an engineered web search to find and display relevant YouTube lectures and module-wise notes, all based on the user's specific university profile.  
* **üìú Paper Analyzer & PYQ Manager:** A tool for analyzing Previous Year Question (PYQ) papers.  
  1. A user selects one of their courses from a dropdown.  
  2. They upload a PYQ PDF.  
  3. The backend (using pdfreader) analyzes the text to find and count the frequency of key topics.  
  4. These results are then **saved to the user's profile** in the database.  
* **‚ö° Express Mode (Exam Season):**  
  * The app automatically detects if the user is in their "exam season" (e.g., November for odd semesters).  
  * If they are, the dashboard replaces the "Upcoming Tasks" card with a dynamic "Express Study Options" card, providing direct links to a comprehensive study page for each of their courses.  
  * This "Express Mode" page displays the **real, user-uploaded PYQ analysis**, notes, and summaries, creating an all-in-one revision hub.  
* **üîÉ Automatic Semester Updates:** A node-cron job runs on the server to automatically check and increment a user's semester every 6 months, ensuring their course list and context are always up-to-date.

## **üõ†Ô∏è Tech Stack**

This project is built with a modern, decoupled, full-stack architecture.

| Component | Technology | Description |
| :---- | :---- | :---- |
| **Frontend** | **React (with Vite)** | A fast, modern React frontend built in TypeScript. |
|  | **Tailwind CSS** | For utility-first styling and the dark-mode theme. |
|  | **shadcn/ui** | For the beautiful, accessible component library. |
|  | **React Router** | For all client-side navigation. |
| **Backend** | **Node.js** | The core JavaScript runtime. |
|  | **Express.js** | For building the RESTful API endpoints. |
|  | **MySQL** | The relational database for all user data, courses, and cached analysis. |
| **Authentication** | **JWT (JSON Web Tokens)** | For secure, stateless user sessions. |
| **AI Features** | **Gemini API** | Powers the chatbot, summarizer, and course analysis. |
| **Scraping Engine** | **Puppeteer** | A headless browser used to perform intelligent web searches. |
| **"Local NLM"** | **pdfreader** / **compromise.js** | Used for robust PDF text extraction and heuristic-based text analysis. |
|  | **tesseract.js** (OCR) | Used as a fallback to read text from image-based PDF calendars. |

## **‚öôÔ∏è How Our "Engineered Search" Works**

A core strength of Bytewise is its ability to find content without relying on a single website or a paid, closed-source API.

**Problem:** How do you find a student's courses or academic calendar, which could be on any university website with any HTML structure?

**Solution: The Hybrid Scraper**

1. **Engineered Query:** The system builds a hyper-specific search query based on the user's profile (e.g., "KTU CSE s5 academic schedule").  
2. **Scrape Search Results:** Puppeteer performs a full web search on an open-source engine (like DuckDuckGo) and scrapes the **top 4 URLs**. It prioritizes official .edu links.  
3. **Iterative Analysis (Pass 1):** It visits the first URL and scrapes all its raw text.  
4. **Local NLP Extraction (Pass 1):** This text is passed to our "Lightweight NLM" (e.g., local-nlp.service.js), which uses a set of smart rules, keywords, and regular expressions to find and extract the relevant data (e.g., course names).  
5. **Iterative Analysis (Pass 2):** If the first pass on a page fails to find text, the system *then* attempts a "deep" parse, looking for specific download links (like .pdf or drive.google.com) and analyzing the text *around* them.  
6. **Success or Next:** If courses are found, the process stops and saves the data. If not, it moves to the next URL in the search results and tries again.

This two-pass, multi-url approach makes Bytewise incredibly resilient and adaptable to the real-world web.

## **üèÅ Getting Started**

To get a local copy up and running, follow these simple steps.

### **Prerequisites**

* [Node.js](https://nodejs.org/en) (v18 or later)  
* [MySQL](https://www.mysql.com/downloads/) (or a client like XAMPP/WAMP)  
* A Google AI Studio API key (for Gemini features)

### **1\. Backend Setup**

\# 1\. Clone the repository  
git clone \[https://github.com/your-username/bytewise.git\](https://github.com/your-username/bytewise.git)  
cd bytewise/server

\# 2\. Install dependencies  
npm install

\# 3\. Create your environment file  
\# (Create a file named .env in the /server directory)  
\#  
\# Add the following, replacing with your credentials:  
\#  
\# PORT=3001  
\# DB\_HOST=localhost  
\# DB\_USER=root  
\# DB\_PASSWORD=your\_mysql\_password  
\# DB\_NAME=bytewise\_db  
\#  
\# JWT\_SECRET=a-very-strong-and-secret-key-for-bytewise  
\# GEMINI\_API\_KEY=YOUR\_GOOGLE\_AI\_STUDIO\_KEY\_HERE

\# 4\. Set up the database  
\# Log in to your MySQL shell  
mysql \-u root \-p

\# Run the following SQL commands to create the database and all tables:  
CREATE DATABASE IF NOT EXISTS bytewise\_db;  
USE bytewise\_db;

CREATE TABLE IF NOT EXISTS users (  
    id INT PRIMARY KEY AUTO\_INCREMENT,  
    email VARCHAR(255) NOT NULL UNIQUE,  
    password VARCHAR(255) NOT NULL,  
    university VARCHAR(255) NOT NULL,  
    program VARCHAR(255) NOT NULL,  
    semester INT NOT NULL,  
    scheme INT NULL,  
    last\_semester\_update DATE,  
    created\_at TIMESTAMP DEFAULT CURRENT\_TIMESTAMP  
);

CREATE TABLE IF NOT EXISTS courses (  
    id INT PRIMARY KEY AUTO\_INCREMENT,  
    university VARCHAR(255) NOT NULL,  
    scheme INT NULL,  
    program VARCHAR(255) NOT NULL,  
    semester INT NOT NULL,  
    course\_code VARCHAR(50) NOT NULL,  
    course\_name VARCHAR(255) NOT NULL,  
    UNIQUE KEY unique\_course (university, scheme, program, semester, course\_name)  
);

CREATE TABLE IF NOT EXISTS pyq\_analysis\_topics (  
    id INT PRIMARY KEY AUTO\_INCREMENT,  
    user\_id INT NOT NULL,  
    course\_name VARCHAR(255) NOT NULL,  
    topic\_name VARCHAR(255) NOT NULL,  
    frequency INT NOT NULL,  
    created\_at TIMESTAMP DEFAULT CURRENT\_TIMESTAMP,  
    FOREIGN KEY (user\_id) REFERENCES users(id) ON DELETE CASCADE,  
    UNIQUE KEY unique\_pyq\_topic (user\_id, course\_name, topic\_name)  
);

CREATE TABLE IF NOT EXISTS schedule\_cache (  
    id INT PRIMARY KEY AUTO\_INCREMENT,  
    user\_id INT NOT NULL,  
    event\_name VARCHAR(255) NOT NULL,  
    event\_date DATE NOT NULL,  
    fetched\_at TIMESTAMP DEFAULT CURRENT\_TIMESTAMP,  
    FOREIGN KEY (user\_id) REFERENCES users(id) ON DELETE CASCADE,  
    UNIQUE KEY unique\_event\_for\_user (user\_id, event\_name, event\_date)  
);

\# 5\. Run the backend server  
npm run dev  
\# Your backend is now running on http://localhost:3001

### **2\. Frontend Setup**

\# 1\. Open a new terminal and navigate to the project's root folder  
cd bytewise 

\# 2\. Install dependencies  
npm install

\# 3\. Add shadcn/ui components (if they are missing)  
\# This step is often not needed if you've cloned the repo with the files.  
\# npx shadcn@latest add toast use-toast button card input label ...etc.

\# 4\. Run the frontend server  
npm run dev  
\# Your frontend is now running on http://localhost:5173

You can now open http://localhost:5173 in your browser and use the application.